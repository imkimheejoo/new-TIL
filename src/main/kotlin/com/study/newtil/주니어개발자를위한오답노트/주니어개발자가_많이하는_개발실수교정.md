## Naming

### get vs find
- get: 무조건 not null 즉, 데이터 없을때 NotFoundException
  - get은 단순히 정보를 가져오는 느낌이지 비즈니스 코드나 복잡한 로직을 통해 찾아오는게 아니다.
- find: nullable, 데이터가 없으면 Optional/Null 반환


## 객체

### VO의 장점
- 일례로 어떤 객체를 함수의 파라미터로 넘긴 후 다음 로직 실행 시 객체의 값이 바뀌면 언제 어디서 바뀐건지 하나하나 디버깅해야하는 이슈가 있다.
- 그래서 VO로 만들게 되면 데이터의 일관성이 보장되기 때문에 이 객체가 있는 로직만 파악하면 된다. (= 복잡도가 줄어든다.)

### DTO 
- 데이터 전송 객체 (모두 public)
- 데이터만 있는 객체라서 비즈니스 로직이 없어야 한다!

### Entity
- Id (식별자)가 있어야 하고 수명 주기가 있으며 **대체로** 디비에 저장되는 내용 (DB Entity != Entity)
  - 그치만 대부분 Entity를 디비용으로 쓰이는 곳이 많아서 항상 디비와 연관이 있도록 사용하긴한다..
  - DB Entity =  PO (Persistence Object) ex. Jpa의 @Entity

### 행동위주의 사고로 객체를 만들자!
- 객체를 만들 때 상태값에 기반한 객체가 아니라 행동에 기반한 객체를 만들자
  - 인터페이스를 정의할 때 하는 사고와 같은 사고로 만들면 될 것 같다.
  - cc. duck typing (행동이 같다면 같은 클래스이다)

### 순환 참조가 일어났을 경우
> 순환참조가 일어나면 Serialize 불가능
> 
> N+1 이슈

- 순환참조가 일어날만큼 결합도가 높으면 하나로 묶자
- 간접참조로 풀자
  - ex) A -> B -> A 일때 B가 A id 가지고 있기 (A는 B그대로 가져도 됨)
    - A는 필요할때 id로 찾아서 가져오기
- 순환참조가 일어나는 코드는 별도로 클래스로 빼보자
- 순환참조를 해결했을 때 복잡도를 낮추고 응집도를 높인다.
  - ex) mappedby 신경 쓸 일 X
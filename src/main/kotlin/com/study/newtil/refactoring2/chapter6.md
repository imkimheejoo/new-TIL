# 6장 기본적인 리팩터링

## 6.1 함수 추출하기

함수로 추출하는 기준이 되는 요소

1. 코드 길이
    - 한 함수는 한 화면을 넘어가면 좋지 않다. 라는 규칙도 있다
2. 재사용성
3. 목적과 구현을 분리
    - 코드를 보고 무슨 일을 하는지 파악하기 어렵다면 추출 대상이다

Q. 함수를 짧게 만들면 함수 호출이 많아져 성능이슈가 있지 않을까?
> 요즘은 워낙 성능이 좋아서 이정도는 노이슈

함수 네이밍
> 함수를 새로 만들고 함수이름은 `어떻게 X`, `무엇(목적)을` 하는지 드러나게 지어야 한다.

함수 매개변수 주의할 점

- **매개변수로 온 변수에 값을 대입하는 코드는 위험하다.**
    - 매개변수에 값을 추가해서 리턴하는것도 위험하다. (리턴된 매개변수가 함수 밖에서 사용되는 경우)
    - 다른 변수를 만들어서 그 변수에 대입시켜야 한다.
    - 왜 위험한가? -> 데이터의 영향범위가 너무 넓어져 변경 포인트를 바로 파악하기 어렵기 때문이라고 생각함

## 6.2 함수 인라인하기

리팩터링 과정에서 잘못 추출된 함수들은 다시 인라인해야한다.(원래함수로 합치기)

- 간접호출을 너무 과하개 쓰면 의심해봐야 한다.

### 절차

1. 다형 메서드인지 확인한다.
    - 서브클래스에서 오버라이드하는 메서드는 인라인 하면 안된다.
2. 인라인할 함수를 호출하는 곳을 모두 찾는다.
3. 각 호출문을 함수 본문으로 교체한다.
4. 하나씩 교체할 때마다 테스트한다.
    - 인라인 작업을 한 번에 처리할 필요는 없다. 인라인하기가 까다로운 부분이 있다면 일단 남겨두고 여유가 생길때마다 틈틈이 처리한다.
5. 원래 함수를 삭제한다.

> 인라인하기에 상황이 너무 복잡하면 안하는 것을 추천한다.

## 6.3 변수 추출하기

변수추출을 고려한다고 함은 표현식에 이름을 붙이고 싶다는 뜻이다.

- 이름을 붙이기로 했다면 그 이름이 들어갈 문맥도 살펴야 한다.
- 해당 표현식이 함수내에서만 쓰인다면 변수로 추추르 다른 범위에서도 쓰인다면 함수로 추출

```kotlin
class Order(
    private val quantity: Int,
    private val itemPrice: Int,
) {
    fun price() {
        return this.basePrice - this.quantityDiscount + this.shipping
    }

    fun basePrice(): Int {
        return this.quantity * this.itemPrice
    }

    fun quantityDiscount(): Int {
        return 100
    }

    fun shipping(): Int {
        return Math.min(basePrice() * 0.1, 100)
    }
}
```

## 6.4 변수 인라인하기

변수 추출하기의 반대개념이다.

변수 이름이 원래표현식으로도 충분히 대체가 가능하다면 변수를 인라인 하는것이 좋다.

## 6.5 함수 선언 바꾸기

이름이 좋으면 함수의 구현 코드를 살펴볼 필요 없이 호출문만 보고도 무슨 일을 하는지 파악할 수 있다.

매개변수는 함수의 문맥 또는 사용가능 범위를 지정하는 역할을 한다.

```kotlin

import java.time.LocalDate
import java.time.format.DateTimeFormatter

// as-is
// 사람한정으로만 쓸 수 있는 함수
fun convertToYYYY년MM월DD일(person: Person): String {
    return "person.birth 를 yyyy년 mm월 dd일 형태로 바꿈"
}

// to-be
// 모두 쓸 수 있는 함수 (범위 확장)
fun convertToYYYY년MM월DD일(date: LocalDate): String {
    return date.format(DateTimeFormatter.ofPattern("yyyy년 MM월 dd일"))
}
```

- 매개변수를 어떻게 넣느냐에 따라 활용범위가 달라진다.
- 다른모듈과의 결합도 제거 할 수 있다.
    - Person이 다른 모듈에 있다면 모듈간 결합이 생기거나, Person로직과 함수가 같은 모듈에 있도록 만들어야한다.
    - to-be 에서는 함수가 Person과 전혀 관계 없는 모듈에 둘 수 있으므 모듈간 결합을 제거한다.

인터페이스의 선언부를 바꿀때는 신중해야한다.

- 구현체들이 바뀐 선언부를 다 만족하는지 확인해아한다.

상속 구조 속에 있는 클래스의 메서드를 변경할 때는 자식 클래스들에도 반영이 되기 때문에 신중해야한다.

## 6.6 변수 캡슐화 하기

유효범위가 짤은 변수는 변경이 쉬우나 유효범위가 넓은 변수는 변경이 어렵다.

1. 변수를 바로 접근하는 로직 -> 변수를 반환하는 함수를 호출하도록 변경

- 변수를 캡슐화한 함수를 만들어서 그 함수를 호출하도록 변경한다.

2. 캡슐화된 변수를 변경한다.
    - 함수를 변경한게 아니므로 영향범위가 캡슐화된 변수에만 적용된다.

데이터 캡슐화는 다룬 경우에도 도움을 준다.

- mutable 데이터타입일 경우 데이터 추가/변경을 캡슐화 해서 한곳에 몰아 그 함수를 통해만 접근하게 만들 경우
    - 그 결과 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.
    - 데이터가 어디서 변경되는지 추적이 쉽다?
    - 데이터에 대한 결합도를 낮출 수 있다.
        - 데이터 변경이 다른 로직에 없기 때문에?

> 데이터의 사용 범위가 넓을 수록 적절히 캡슐화 하라!

## 6.7 변수 이름 바꾸기

## 6.8 매개변수 객체 만들기

매개변수들을 객체에 한데 모으면 이 데이터구조가 새로운 추상화 개념이 될 수 있다. (+데이터에 공통으로 적용되는 로직(동작) 추가)

## 6.9 여러 함수를 클래스로 묶기

## 6.10 여러 함수를 변환 함수로 묶기

## 6.11 단계 쪼개기